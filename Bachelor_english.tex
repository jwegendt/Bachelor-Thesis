%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% LaTeX-Rahmen fuer das Erstellen von englischen Bachelorarbeiten
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% allgemeine Einstellungen
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[twoside,12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
%\usepackage{reportpage}
\usepackage{epsf}
\usepackage{graphics, graphicx}
\usepackage{latexsym}
\usepackage[margin=10pt,font=small,labelfont=bf]{caption}

%\usepackage{fontspec}
%\setmainfont{Asana-Math}

\usepackage{amsmath}
\usepackage{array} %for the \newcolumntype macro
\usepackage{amsthm} %for theorems/definitions
\usepackage{thmtools} %for listofheorems TODO: remove/integrate?
\usepackage{bussproofs}

\textwidth 14cm
\textheight 22cm
\topmargin 0.0cm
\evensidemargin 1cm
\oddsidemargin 1cm
%\footskip 2cm
\parskip0.5explus0.1exminus0.1ex

% Kann von Student auch nach persönlichem Geschmack verändert werden.
\pagestyle{headings}

\usepackage[symbol]{footmisc}
\usepackage{hyperref}

\sloppy

\begin{document}


%%%%% Macros %TODO: sollten die wo anders hin/in ein eigenes file?


%Macros for Theorems/Definitions/...
\theoremstyle{definition}
\newtheorem{definition}{Definition}[section]
\newtheorem{theorem}{Theorem}[section]
\newtheorem{example}{Example}[section]

%Macros for possible terms in ND:
\newcommand{\constructor}{K(\overline{e})}
\newcommand{\destructor}{e.d(\overline{e}) }
\newcommand{\patmatch}{e.\textbf{case}\{\overline{K(\overline{x})\Rightarrow e}\}} 
\newcommand{\copatmatch}{\textbf{cocase}\{\overline{d(\overline{x})\Rightarrow e}\}}

%Macros for terms but for examples and such
\newcommand{\exconstructor}[1]{K(#1)}
\newcommand{\exdestructor}[1]{e.d(#1) }
\newcommand{\expatmatch}[1]{\textbf{case}\{#1\}} 
\newcommand{\excopatmatch}[1]{\textbf{cocase}\{#1\}}

%Macros for structural/technical latex stuff
\newcolumntype{L}{>{$}l<{$}} % a left-aligned column in mathmode
\newcolumntype{C}{>{$}c<{$}} % a center-aligned column in mathmode

\newcommand{\alphaunifvar}{\alpha^?}
\newcommand{\betaunifvar}{\beta^?}
\newcommand{\FV}[1]{\text{FV}(#1)}
\newcommand{\listofexpr}{e_1,...e_n}
\newcommand{\listofvar}{x_1,...x_n}
\newcommand{\betaconv}{\equiv_{\beta}^1}
\newcommand{\etaconv}{\equiv_{\eta}^1}
\newcommand{\Ap}[1]{\texttt{Ap}(#1)}

\newcommand{\partition}{\;|\;}
\newcommand{\code}[1]{\texttt{#1}}
\newcommand{\True}{\mathtt{True}}
\newcommand{\False}{\mathtt{False}}
\newcommand{\Nil}{\mathtt{Nil}}

\newcommand{\Int}{\mathsf{Int}}
\newcommand{\Bool}{\mathsf{Bool}}

\newcommand{\constraints}{\mathcal{C}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Layout Title page
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 
\begin{titlepage}
 \begin{center}
  {\LARGE Eberhard Karls Universität Tübingen}\\
  {\large Mathematisch-Naturwissenschaftliche Fakultät \\
Wilhelm-Schickard-Institut für Informatik\\[4cm]}
  {\huge Bachelor Thesis Computer Science\\[2cm]}
  {\Large\bf  Higher-Order Unification for Data and Codata Types\\[1.5cm]}
 {\large Julia Wegendt}\\[0.5cm]
Date\\[3cm]
{\small\bf Reviewer}\\[0.5cm]
 {\large Prof. Dr. Klaus Ostermann}\\
  {\footnotesize Department of Computer Science\\
	University of Tübingen}
\end{center}
	
\end{titlepage}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Layout back of title page
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\thispagestyle{empty}
\vspace*{\fill}
\begin{minipage}{11.2cm}
\textbf{Wegendt, Julia}\\
\emph{Higher-Order Unification for Data and Codata Types}\\ Bachelor Thesis Computer Science\\
Eberhard Karls Universität Tübingen\\
Period: from-till
\end{minipage}
\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\pagenumbering{roman}
\setcounter{page}{1}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Abstract
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section*{Abstract}

Write here your abstract.
\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Acknowledgements
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{Acknowledgements}

Write here your acknowledgements.

\cleardoublepage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Table of Contents
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\renewcommand{\baselinestretch}{1.3}
\small\normalsize

\tableofcontents

\renewcommand{\baselinestretch}{1}
\small\normalsize

\listoftheorems

\cleardoublepage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Main Part
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\pagenumbering{arabic}
\setcounter{page}{1}

\section{Introduction}

%TODO

\section{The Untyped Calculus ND}

I will be introducing the Untyped Calculus ND, based on ... %TODO citation

\subsection{Syntax of the Untyped Calculus ND}

%TODO: introduction

%% explanation of lists

Some knowledge of notation is necessary to familiarize oneself with the syntax of the Untyped Calculus.
$X$ represents a (possibly empty) sequence $X_1, ... X_i, ... X_n$.  
%TODO: das mit dem simultaneos indexing besser verstehen
%TODO: das mit dem X_1, ... 
%TODO: will ich variablen und co auch hier einführen?
\\
A pattern match $e.\textbf{case}\{\overline{K(\overline{x})\Rightarrow e}\}$ 
matches a term $e$ against a sequence of clauses, each clause consisting of a constructor and an expression.
The expression associated with first constructor %TODO: oder kann es nur eine geben?  
that matches the term is the result of the pattern match. %TODO: kann man hier überhaupt von result sprechen?
For a copattern match $\textbf{cocase} \{\overline{d(\overline{x}) \Rightarrow e}\}$
the same rules apply, but instead of constructors, the term is matched against destructors.

\begin{definition}[Terms of the Calculus ND]
    \begin{align*}
    e,r,s,t ::&=  x,y  \tag*{Variable} \\
        &\partition\constructor \tag*{Constructor} \\
        &\partition\destructor  \tag*{Destructor}\\
        &\partition\patmatch  \tag*{Pattern match}\\
        &\partition\copatmatch  \tag*{Copattern match}
    \end{align*}
    In pattern and copattern matches, every con- or destructor may occur no more than once.
    %TODO: erklären warum? => verstehen warum (das reicht)?
\end{definition}

Let's look at some examples to ... %TODO: Formulierung 
All rudimentary datatypes can be constructed through constructors: 
The Booleans $\True$ and $\False$ are constructors on an empty sequence. We can of course represent integers as peano numbers using constructors.

Abstract data types like lists, arrays, records etc. can similarly be defined through constructors:
$\mathtt{Cons(True, Cons(False, Nil))}$ and $\mathtt{Date(27, 08, 2005)}$. 

We can use Pattern matching to represent conditionals:
Like if statements: if $e_1$ $e_2$ else $e_3$ which is analogous to:
$e_1.\expatmatch{\True\Rightarrow e_2, \False\Rightarrow e_3}$
Or the expression which tests whether a given list starts with $\True$:
$e.\expatmatch{\mathtt{Cons(True,x)\Rightarrow True, Nil\Rightarrow False, Cons(x, y)}\Rightarrow \code{False}}$

\subsection{Free Variables, Substitutions, Contexts}

\begin{definition}[Free Variables]
    The set of free variables of a term $e$ is FV($e$). A term is closed if this set is empty.
    Free Variables are defined recursively over the structure of terms as follows:
    \begin{align*}
        \begin{split}
            \FV{x} &:= \{x\}\\
            \FV{\exconstructor{\listofexpr}} &:= \FV{e_1} \cup \dots\cup \FV{e_n}\\
            \FV{\exdestructor{e_1,...e_n}} &:= \FV{e}\cup FV(e_1) \cup \dots \cup \FV{e_n}\\
            \FV{\patmatch} &:= \FV{e}\cup (\FV{e_1}\backslash\overline{x})\cup \dots\cup (\FV{e_n}\backslash\overline{x})\\
            \FV{\copatmatch} &:= (\FV{e_1}\backslash\overline{x})\cup \dots\cup (\FV{e_n}\backslash\overline{x})
        \end{split}
    \end{align*}
%TODO: explanation
\end{definition}


\begin{definition}[Substitution]
    A simultaneous substitution $\sigma$ of the terms $\listofexpr$ for the distinct variables $\listofvar$ is defined as follows:
    \begin{align*} %TODO: geht das mit dem distinct da oben unter?
        \sigma ::= [\listofexpr \backslash\listofvar]
    \end{align*}
\end{definition}

The set of variables for which the substitution is defined is called the domain.
The set of free variables which appear in the substitution is called the range. %TODO: formulierung ausschmücken?

\begin{definition}[Domain and Range of a Substitution]
    The definitions of Domain and Range of a Substitution are as follows:
    \begin{align*}
        \texttt{dom}([\listofexpr/\listofvar]) &:= \{\listofvar\}\\
        \texttt{rng}([\listofexpr/\listofvar]) &:= \FV{e_1}\cup \dots\cup\FV{e_n}
    \end{align*}
\end{definition}

What is actually interesting is what happens when we appy a substitution to an expression

\begin{definition}[Action of a Substitution]
    The action of a substitution $\sigma$ on a term $e$, written as $e \sigma$ and is defined as follows:
    \begin{align*}
        x[\listofexpr / \listofvar] :=& e_i \quad(\text{if } x=x_i) \\
        y\sigma :=& y\quad (\text{if }y\notin \texttt{dom}(\sigma))\\
        (\exconstructor{\listofexpr})\sigma :=& \exconstructor{e_1 \sigma,\dots , e_n \sigma}\\
        (\exdestructor{\listofexpr}) \sigma:=& (e \sigma).d(e_1 \sigma,\dots , e_n \sigma)\\
        (\patmatch)\sigma:=& (e\sigma).\textbf{case}\{\overline{K(\overline{y}\Rightarrow (e\sigma')\sigma)}\}\\
        (\copatmatch)\sigma:=& \excopatmatch{\overline{(d(\overline{y})\Rightarrow(e\sigma')\sigma)}}
    \end{align*} 
    Where $\sigma'$ is a substitution that ensures that we don't bind new variables: 
    $\sigma'$ has the form $[y_1,\dots, y_n/\listofvar]$ and all $y_i$ are fresh for both the domain and the range of $\sigma$.
\end{definition}

The composition of two substitutions $\sigma_2 \circ \sigma_1$ which is equivalent to first applying the substitution $\sigma_1$, then the substitution $\sigma_2$.

\begin{definition}[Composition of Subsitutions]
    Given two substitutions
    \begin{align*}
        \sigma_1 := [\listofexpr/\listofvar],\qquad \sigma_2 := [t_1,\dots,t_m/y_1,\dots,y_m]
    \end{align*}
    Composition is defined as:
    \begin{align*}
        \sigma_2\circ\sigma_1 := [e_1\sigma_2,\dots,e_n\sigma_2,t_j,\dots,t_k/\listofvar,y_j,\dots,y_k]
    \end{align*}
    Where $j, \dots, k$ ist the greatest sub-range of indices $1,\dots,m$ such that none of the variables $y_j$ to $y_k$ is in the domain of $\sigma_1$ 
    %TODO: kann man das besser formulieren?
\end{definition}

\begin{definition}[Idempotency]
    A substitution $\sigma$ is idempotent, iff. $\sigma \circ \sigma = \sigma$.
    Concretely, this means that it doesn't matter how often we apply a substitution to a given problem.
\end{definition}

For example, $[\excopatmatch{\Ap{x}\Rightarrow x} / y]$ is idempotent, since:
\begin{align*}
    &[\excopatmatch{\Ap{x}\Rightarrow x} / y] \circ [\excopatmatch{\Ap{x}\Rightarrow x} / y] \\
    &= [\excopatmatch{\Ap{x}\Rightarrow x}[\excopatmatch{\Ap{x}\Rightarrow x} / y] / y] \\
    &= [\excopatmatch{\Ap{x}\Rightarrow x} / y] 
\end{align*}

On the other hand, the substitution $[\excopatmatch{\Ap{y}\Rightarrow x} / x]$ is not idempotent, since:
\begin{align*}
    &[\excopatmatch{\Ap{y}\Rightarrow x} / x] \circ [\excopatmatch{\Ap{y}\Rightarrow x} / x]\\ 
    &= [\excopatmatch{\Ap{y}\Rightarrow x}[\excopatmatch{\Ap{y}\Rightarrow x} / x] / x] \\
    &= \excopatmatch{\Ap{y}\Rightarrow (\Ap{y}\Rightarrow x) } \neq [\excopatmatch{\Ap{y}\Rightarrow x} / x]
\end{align*}

\begin{definition}[More General] 
    A substitution $\sigma$ is more general than a substitution $\theta$, iff. there exists a mapping $\tau$, such that: $\theta = \tau \circ \sigma$.
\end{definition} % TODO: andere namen? maybe

For example, look at the following unification problem where we are trying to substitute types for two unification variables:
\begin{align*}
    \texttt{List}(\alphaunifvar) &\equiv \texttt{List}(\betaunifvar)\\
    \alphaunifvar &\equiv \texttt{Int}
\end{align*}

One solution might be: $\theta = [Int, Int / \alphaunifvar, \betaunifvar]$, 
so substituting Int for both unification variables.
The more general solution is $\sigma = [Int,\alphaunifvar / \alphaunifvar, \betaunifvar]$ (substituting $\alphaunifvar$ for $\betaunifvar$, and substituting Int for $\alphaunifvar$), however.
This is because there exists a mapping $\tau = [Int / \alphaunifvar]$, such that:
\begin{align*}
    \tau \circ \sigma &= [Int[Int/\alphaunifvar], \alphaunifvar[Int/\alphaunifvar] / \alphaunifvar, \betaunifvar]= [Int, Int / \alphaunifvar, \betaunifvar]= \theta
\end{align*}
%TODO: das ist ein vorgriff! diese sektion doch weiter runter schieben? oder die definition von lösung weiter oben oder so? oder eben ein anderes beispiel was nicht mit unifikation zu tun hat?
\iffalse
For example, for the problem $\alpha x = zx$, both $\sigma_1 = [z/\alpha]$ and $\sigma_2 = [\lambda y.zx, \lambda y.zx/ \alpha, z]$ are solutions, %TODO: zeigen warum?
but $\sigma_1$ is more general than $\sigma_2$, since there exists a substitution $\sigma_3 = [\lambda y.zx/z]$, and:
\begin{align*}
    \sigma_3 \circ \sigma_1 = [z[\lambda y.zx/z], \lambda y.zx /\alpha, z] = [(\lambda y.zx), \lambda y.zx /\alpha, z] = \sigma_2  
\end{align*}
\fi

\subsection{Conversion}

\begin{definition}[Beta-Conversion]
    A single step of beta-conversion $e_1 \betaconv e_2$ is defined as follows:
    \begin{align*}
        \constructor.\textbf{case}\{\dots,\exconstructor{\overline{x}}\Rightarrow e,\dots\} 
        \betaconv & e[\overline{e}/\overline{x}] \tag{$\beta$-Data}\\
        \excopatmatch{\dots,d(\overline{x}) \Rightarrow e, \dots}.d(\overline{e})
        \betaconv & e[\overline{e}/\overline{x}]  \tag{$\beta$-Codata}
    \end{align*}
    We require that the constructor $K(\overline{e})$ and the constructor $\exconstructor{\overline{x}}$ have the same number of arguments.
    This, in short ensures that we don't generate stuck terms, i.e. terms that can't be evaluated. %TODO: warum hier und nicht in der syntaxdefinition?
\end{definition}
Some examples:
\begin{align*}
    &\True.\expatmatch{\False\Rightarrow \True, \True \Rightarrow \False}\betaconv\False\\
    &\excopatmatch{\Ap{x}\Rightarrow \True}.\Ap{x}\betaconv \True[x/x] = \True \\
    &\excopatmatch{\Ap{y}\Rightarrow y}.\Ap{x} \betaconv y[x/y]= x
\end{align*}
Intuitively, beta-conversion means function application or the reduction under pattern or copattern matching. %TODO: macht das so sinn? sollte ich das mehr erklären? sind die beispiele hier überhaupt gut?

\begin{definition}[Eta-Conversion for Codata]
    A single step of eta-conversion $e_1 \etaconv e_2$ is defined as follows:
    \begin{align*}
        \excopatmatch{\overline{d(\overline{x})\Rightarrow e.d(\overline{x})}}
        \etaconv & e \quad (\text{if } \overline{x}\notin \FV{e}) \tag{$\eta$-Codata}
    \end{align*}
\end{definition}

\section{Simple Types}

We want to be able to use the unification algorithm to discern types for given terms. 
To start, let's look at some examples terms and their types:
\begin{align*}
    &\mathtt{5}: \Int\\
    &\mathtt{False}: \Bool\\
    &\mathtt{Tup(1,True)}: \mathsf{Pair(Int, Bool)}\\
    &(1, \True): \mathsf{LPair(Int, Bool)}\\
    &\mathtt{Cons(1, Cons(2, Nil))}: \mathsf{List(Int)}\\
    &e.\expatmatch{\mathtt{True\Rightarrow False, False \Rightarrow True}}: \mathsf{Bool \rightarrow Bool}\\
    &\mathtt{Trues} = \excopatmatch{hd \Rightarrow \True, tl \Rightarrow \mathtt{Trues}}: \mathsf{Stream(Bool)}\\
\end{align*}


\subsection{Typing Rules}
To be able to give our examples a formal basis, we will introduce typing rules. %TODO: ich mag die satzstruktur nicht
These will not cover all the types one could construct using our calculus, 
but instead all the basic composite types.
This will be enough to construct examples covering each case we have to consider,
and hopefully give an idea how to construct any type.

When writing $\Gamma\vdash t:\tau$, we mean that from the variables and their types in $\Gamma$, 
we can deduce that $t$ has the type $\tau$.

\begin{prooftree}
    \AxiomC{$x:\tau \in \Gamma$}\RightLabel{\textsc{Var}}
    \UnaryInfC{$\Gamma\vdash x:\tau$}
\end{prooftree}
\begin{prooftree}
    \AxiomC{}\RightLabel{\textsc{Nil}}
    \UnaryInfC{$\Gamma\vdash \Nil:\mathsf{List(\tau)}$}
\end{prooftree}
\begin{prooftree}
    \AxiomC{$\Gamma\vdash t_1:\tau$}\RightLabel{\textsc{Cons}}
    \AxiomC{$\Gamma\vdash t_2:\mathsf{List(\tau)}$}
    \BinaryInfC{$\Gamma\vdash \mathtt{Cons(\mathnormal{t_1,t_2})}:\mathsf{List(\tau)}$}
\end{prooftree}
\begin{prooftree}
    \AxiomC{$\Gamma\vdash t:\mathsf{List(\tau')}$}\RightLabel{\textsc{Case-List}}
    \AxiomC{$\Gamma\vdash t_1:\tau$}
    \AxiomC{$\Gamma, y:\tau',z:\mathsf{List(\tau')}\vdash t_2:\tau$}
    \TrinaryInfC{$\Gamma\vdash t.\expatmatch{\Nil\Rightarrow t_1, \mathtt{Cons(\mathnormal{y,z})}\Rightarrow t_2}:\tau$}
\end{prooftree}
\begin{prooftree}
    \AxiomC{$\Gamma:t:\mathsf{Stream(\tau)}$}\RightLabel{\textsc{Hd}}
    \UnaryInfC{$\Gamma\vdash t.\mathtt{hd}:\tau$}    
\end{prooftree}
\begin{prooftree}
    \AxiomC{$\Gamma\vdash t:\mathsf{Stream(\tau)}$}\RightLabel{\textsc{Tl}}
    \UnaryInfC{$\Gamma\vdash t.\mathtt{tl}:\mathsf{Stream(\tau)}$}
\end{prooftree}
\begin{prooftree}
    \AxiomC{$\Gamma\vdash t_1:\tau$}\RightLabel{\textsc{Stream}}
    \AxiomC{$\Gamma\vdash t_2:\mathsf{Stream(\tau)}$}
    \BinaryInfC{$\Gamma\vdash \excopatmatch{\mathtt{hd}\Rightarrow t_1, \mathtt{tl}\Rightarrow t_2}: \mathsf{Stream(\tau)}$}
\end{prooftree}
\begin{prooftree}
    \AxiomC{$\Gamma\vdash t_1:\tau_1$}\RightLabel{\textsc{Lpair}}
    \AxiomC{$\Gamma\vdash t_2:\tau_2$}
    \BinaryInfC{$\Gamma\vdash t.\expatmatch{\mathtt{fst}\Rightarrow t_1, \mathtt{snd} \Rightarrow t_2}:\mathsf{LPair(\tau_1, \tau_2)}$}
\end{prooftree}
\begin{prooftree}
    \AxiomC{$\Gamma\vdash t_1:\tau_1\rightarrow\tau_2$}\RightLabel{\textsc{App}}
    \AxiomC{$\Gamma\vdash t_2:\tau_1$}
    \BinaryInfC{$\Gamma\vdash t_1.\Ap{t_2}:\tau_2$}
\end{prooftree}
\begin{prooftree}
    \AxiomC{$\Gamma,x: t_1\vdash t:\tau_2$}\RightLabel{\textsc{Cocase}}
    \UnaryInfC{$\Gamma\vdash\excopatmatch{\Ap{x}\Rightarrow t}:\tau_1\rightarrow \tau_2$}
\end{prooftree}


\section{First-Order Unification}

We want to slowly make our way to higher-order unification, and thus touch on simpler problems first. 
Furthermore, we need a couple concepts more to be able to talk about unification problems and describe our algorithm. 

%TODO: a? the? unification problem? 
The Unification Problem is described by a set of equations with expressions on each side $\overline{e\equiv e}$ containing unknown unification variables $\alphaunifvar_1, \alphaunifvar_2, ...$, %TODO: lieber mit alpha_n oder lieber nur alpha? 
where our goal is to find a simultaneous substitution $[\listofexpr / \alphaunifvar_1, \dots, \alphaunifvar_n]$ which substitutes expressions for unification variables, 
such that the sides of the given equations are the same (respectively). 

\begin{definition}[Solution]
    A solution to a given unification problem is described by a simultaneous substitution $[\listofexpr / \alphaunifvar_1, \dots, \alphaunifvar_n]$
    which when applied to the problem solves it, i.e. makes the sides of the equations equal %TODO: formellere formulierung?
\end{definition}
    
\begin{definition}[Most General]
    A solution is the most general unifier (mgu), iff. it is more general than all other solutions.
\end{definition} 

Now let's take a look at first-order unification, which is a pretty limited subproblem, 
but in many applications all we need, as in most type checking.

\begin{definition}[First-Order unification]
\begin{align*}
    e,r,s,t ::&= \alphaunifvar, \betaunifvar \tag*{Unification variable}\\
    &\partition x\tag*{Variable} \\
    &\partition \constructor \tag*{Constructor}
\end{align*}
\end{definition}

Some examples:
$\alphaunifvar \equiv \True$ has the solution $[\True/\alphaunifvar]$.
$\mathtt{True \equiv False}$ doesn't have a solution.

$\mathsf{Int \rightarrow \alphaunifvar \equiv Int \rightarrow Bool}$ has the solution $[\Bool/\alphaunifvar]$. 
On the other hand, $\mathsf{\alphaunifvar\equiv List(\alphaunifvar)}$ should not have a solution. This is the negative example for the occur check rule below.
%TODO: anders?


\begin{theorem}[Decidability of First-Order Unification]
    For first-order unification, there exists an algorithm on equneutralations $E$, which always terminates, and returns the solution if there exists one. 
    In particular, this solution is always a mgu (i.e. if there is a solution, then there always exists a most general one).
\end{theorem}

\begin{definition}[Unification algorithm for First-Order Unification ]
    $\perp$ is the symbol for fail.
    The algorithm is defined by non-deterministically applying the below rules:
    \begin{align*}
        E & \cup \{ e \equiv e\} \Rightarrow E \tag{delete}\\
        E & \cup \{\exconstructor{e_1 ... e_n} \equiv \exconstructor{t_1 ... t_n}\} \Rightarrow E \cup \{e_1 \equiv t_1, ... e_n \equiv t_n\}\tag{decompose}\\
        E & \cup \{K_1(e_1,...e_n) \equiv K_2(t_1, ..., t_m)\}  \Rightarrow \perp \quad\text{if $K_1 \neq K_2$ or if $n\neq m$} \tag{conflict}\\
        E & \cup \{e \equiv \alphaunifvar\} \Rightarrow E \cup \{\alphaunifvar \equiv e\}\tag{swap}\\ 
        E & \cup \{\alphaunifvar \equiv e\} \Rightarrow E[e/\alphaunifvar] \cup \{\alphaunifvar \equiv e\} \quad\text{if $\alphaunifvar \in E$ and $\alphaunifvar \notin e$}  \tag{eliminate}\\
        E & \cup \{\alphaunifvar \equiv K(e_1,...e_n)\}\Rightarrow \perp \quad \text{if $\alphaunifvar \in e_1,...e_n$} \tag{occurs check} 
    \end{align*}
\end{definition} 
%TODO: will ich die regeln umsortieren?

This algorithm is based on the version presented by Martelli and Montanari in \cite{10.1145/357162.357169},
adapted to our syntax.

\section{Higher-Order Unification}

\begin{definition}[Higher-Order Unification]
    \begin{align*}
        e,r,s,t  ::&= \alphaunifvar\sigma, \betaunifvar\sigma \tag*{Unification Variables with substitution}\\ %TODO: name? 
            &\partition x  \tag*{Variable} \\
            &\partition\constructor \tag*{Constructor} \\
            &\partition\destructor  \tag*{Destructor}\\
            &\partition\patmatch  \tag*{Pattern match}\\
            &\partition\copatmatch  \tag*{Copattern match}
    \end{align*}
\end{definition}

Note that this is encompassed our syntax described in Section 2, %TODO: schlechter stil?
but with the addition of unification variables with substitutions. 
To illustrate the need for this substitution, look at what problem arises when omitting the substitution:
Take the following example: $\excopatmatch{\Ap{x}\Rightarrow\alphaunifvar}.\Ap{y}\equiv\betaunifvar$. 
First focus on the left side and notice that there is a redex. What happens if we reduce it?

\begin{align*}
    \excopatmatch{\Ap{x}\Rightarrow\alphaunifvar}.\Ap{y}\betaconv\alphaunifvar[y/x]    
\end{align*}

This motivates our need for substitutions: We may need to apply substitutions to unification variables.
Note that this is \textit{not} possible in first-order unification, since we don't create subsitutions through redexes! 

When the substitution is trivial, we may  write $\alphaunifvar, \betaunifvar$ instead.

In higher-order unification in contrast to in first-order unification, we are not interested in syntactic equality,but want a broader set of terms to be equal to one another.
Depending on the type of unification problem one wants to solve, they may want to only include beta-equality or both 
beta- and eta-equality.

This further motivates our use of the symbol $\equiv$ so far. Whereas in first-order unification it just stands for syntactic equality, 
in higher-order unification, I use it to mean syntactically equality, beta-equality or eta-equality.
This essentially means that two terms are equivalent if they are equivalent after function application and/or are equivalent externally.

Let's next consider a few examples:
The problem $\alphaunifvar.\texttt{Ap}(5) \equiv 5$ has multiple solutions:
$[\excopatmatch{\texttt{Ap}(x)\Rightarrow x} / \alphaunifvar]$ and $[\excopatmatch{\texttt{Ap}(x)\Rightarrow 5} / \alphaunifvar]$,\\
where \texttt{Ap} is a function applicator. 
Thus, the two given solutions are the identity function and the constant function 5, which when consuming the argument 5, both give back 5.
In this case there also doesn't exist an mgu.
%TODO: more!


To be able to discuss unification equations in more depth, we need one more concept:

\begin{definition}[Constraint]
    \begin{align*}
        C ::= \top \partition \bot \partition \Psi \vdash e\equiv t\\
        \mathcal{C} ::= C \wedge \mathcal{C}
    \end{align*}
    $\Psi$, called context is just a list of distinct variables $x_1,...x_n$ and may be empty.
\end{definition}
$\Psi \vdash e\equiv t$ means that given the variables $\Psi$, we deduce that $e\equiv t$.
$\Psi$ may contain variables that occur in or are even bound in $e,t$. 
$\Psi$ contains those variables we have seen before and want to remember. This motivates the naming of $\Psi$ as context, as well.
%TODO: ist das offensichtlich?

Why do we need a formal definition here? We don't solve our unification problem in one huge step, but
work on it incrementally, solving parts of terms and remembering the information we have learned from these parts.
We want to be able to talk about these processes formally.

We formulate our constraints from a given unification problem as follows:
We take each given equation and formulate a constraint $K$ with empty context $\Psi$. We join them using ands: %TODO: formulierung?
$\overline{e\equiv t}$ becomes: $\constraints = C_1 \wedge ... \wedge C_n  \vdash e_1 \equiv t_1 \wedge ...\wedge \vdash e_n \equiv t_n $  

For clarification, $C \wedge \mathcal{C}$ is the regular logical and thus, 
and $\top \wedge \constraints = \constraints$ as well as $\bot \wedge \constraints = \bot$
%TODO: ist das offensichtlich?

\begin{theorem}[Decidability of Higher-Order Unification]
    Higher-order unification includes unification problems containing higher-order terms (equivalent to lambda abstractions),
    and is covered by our introduced syntax. %TODO: bessere formulierung?
    Higher-order unification is not decidable. This can be proven through reducing Hilbert's tenth problem to the unification problem.
\end{theorem}


\section{Pattern Unification}

Pattern unification, also sometimes called the pattern fragment
is a subsection of Higher-Order Unification,
% It can be seen as an extension of first-order unification
with its solution being similarly simple as the one to first-order unification.
It was described first by Miller in \cite{10.1093/logcom/1.4.497}.
Since we are dealing with what amounts to an extension to the lambda calculus (as our syntax also contains constructors), we need to extend our definition to more than just function applications. 
This means that (in practice,) the pattern fragment described by Miller is a subset of our definition.

\begin{definition}[Pattern]
    A pattern is any term $p$ 
    \begin{align*}
        p ::= \alphaunifvar, \betaunifvar \partition p.d(\listofvar)
    \end{align*}
    where it holds that all $\listofvar$ are distinct variables.
\end{definition}
%The intuition here is that in the above case, $\alphaunifvar$ is an unknown function applied to its arguments $\listofexpr$, 
%and anytime we apply an unknown function, we should read the problem as a definition for the function.
%TODO: mehr erklärung?

If You are familiar with other definitions of patterns, You might have noticed that 
we have omitted the part about the variables being bound. We require this later on when looking at patterns as subterms.
Some examples:
$\alphaunifvar.\Ap{x}.\Ap{y}\equiv x$ is a pattern and has the solution $[\excopatmatch{\Ap{x}\Rightarrow\excopatmatch{\Ap{y}\Rightarrow x}}/\alphaunifvar]$.
$\alphaunifvar.fst \equiv 2$ is a pattern and has the solution $[pair(2,x)/\alphaunifvar]$.

%TODO: beispiele mit anderem destruktor??

\begin{theorem}[Decidability of Pattern Unification]
    Pattern Unification is decidable. If there exists a solution, there also exists a mgu.
\end{theorem}

Note that first-order unification is not a subset of pattern unification. 
Equations containing first-order terms that don't contain patterns still remain solvable.
%TODO: ist das offensichtlich? bzw soll ich das in der einleitung klar machen oder besser beschreiben?

The reason there always exists an mgu lies in the constraint we put on our definition: All the variables must be distinct. 

To illustrate this, take the problem $\alphaunifvar.\Ap{x}.\Ap{x}\equiv x$ (where the variables are \textbf{not} distinct). 
We can name two solutions:
\begin{align*}
    \sigma_1 &= [\excopatmatch{\Ap{x}\Rightarrow \excopatmatch{\Ap{y}\Rightarrow x}}/\alphaunifvar]\\
    \sigma_2 &=[\excopatmatch{\Ap{x}\Rightarrow \excopatmatch{\Ap{y}\Rightarrow y}}/\alphaunifvar]  
\end{align*}
(Intuitively, the solutions say to select the first or second argument of the function applications, respectively.)
These solutions are equivalent, in that no solution is more general than the other. There exists no mgu for this problem.
The solutions aren't unique because the variables aren't unique.
%TODO: ist das beispiel zu ausführlich?

To be able to talk about the algorithms for solving unification problems, we need another definition: %TODO: umformulieren
\begin{definition}[Normal Form]
    The normal form \textbf{NF} is defined as follows:
    \begin{align*}
        n &::= x \partition \alphaunifvar \partition n.d(\overline{v})\partition n.\textbf{case}\{\overline{K(\overline{x})\Rightarrow v}\}\\
        v &::= n \partition K(\overline{v}) \partition \excopatmatch{\overline{d(\overline{x})\Rightarrow v}}
    \end{align*}
    Terms that satisfy the $n$-definition are called neutral terms, $v$-terms are called values.
\end{definition}
Note that these are the terms that do not contain beta-redexes. 
A beta-redex is a term that can be transformed using a beta-conversion.

This is apparent when one tries to construct terms containing beta-redexes in normal form: 
To construct the first kind of beta-redex: $\constructor.\textbf{case}\{\dots,\exconstructor{\overline{x}}\Rightarrow e\}$,
we start with the term $n.\textbf{case}\{\overline{K(\overline{x})\Rightarrow v}\}$, now wanting to subtitute $K(\overline{e})$ for $n$. 
This is not possible because we are limited to neutral terms, which constructors are not part of.
Similarly with the second kind of beta-redex:
$\excopatmatch{\dots,d(\overline{x}) \Rightarrow e, \dots}.d(\overline{e})$, where we could not substitute the cocase in $n.d(\overline{e})$ because we are limited to neutral terms.
        
This underlines the intuition that neutral terms are terms that cannot be reduced because
they contain an term we can't further evaluate (either a variable or a unification variable) in the front.
Values, where we don't have this assurance cannot contain the building blocks for a beta-redex.

Some examples: 
\begin{align*}
    \begin{split}
        r &= \alphaunifvar.\Ap{\excopatmatch{\Ap{x}\Rightarrow x}}, \\
        s &= \excopatmatch{\Ap{x}\Rightarrow \mathtt{Cons(\mathnormal{x}, Cons(\mathnormal{y}, Nil))}},   \\
        t &= \alphaunifvar.\Ap{x_1, x, y, z}
    \end{split}    
\end{align*}
$r$ and $s$ are in normal form and $t$ is a pattern in normal form.

\begin{theorem}
    If a unification problem has a solution, that solution is the same for the normal form of that same problem. 
    No normal form of a problem that doesn't have a solution has a solution either.
\end{theorem}

From this point on, we will only be looking at terms that have a normal form. This is enough in most applications. %TODO: ausschmücken?

This is helpful for us, since we only have to consider normal forms in our algorithm, as in: 
Met with a term, we first reduce it to its normal form, and then solve for our solution.

As an example, the problem $\True.\expatmatch{\True \Rightarrow \alphaunifvar, \False \Rightarrow \mathtt{2}} \equiv \mathtt{3} $ has the solution $[\mathtt{3/\alphaunifvar}]$, 
but this is more obvious after using a beta-reduction on the left-hand side bringing it into normal form:
\begin{align*}
    &\True.\expatmatch{\True \Rightarrow \alphaunifvar, \False \Rightarrow \mathtt{2}} \betaconv \alphaunifvar  \\
    &\implies \alphaunifvar \equiv \mathtt{3}   
\end{align*}

Let's take a look at another example:
\begin{align*}
    &\alphaunifvar \equiv \True \\
    &\alphaunifvar.\expatmatch{\texttt{True} \Rightarrow 2, \texttt{False} \Rightarrow 3} \equiv \betaunifvar
\end{align*}
To find out that $[\mathtt{2}/\betaunifvar]$ is the solution to the second equation, we first need to find out that
$[\True/\alphaunifvar]$ is the solution to the first equation and substitute it in the second.
This is what is called \textit{dynamic} pattern unification, where we hold off on solving some equations we don't have all the information for yet until we know more. 

\section{The Algorithm For Higher-Order Unification}

\subsection{Decomposing Constraints}

It is helpful to simplify our equations a bit before starting the unification process.
We do this by taking out redundant equations, spotting clearly contradictory equations or splitting our equations into smaller parts which we can further simplify and unify.

Let's look at some examples. We would like the following to be true:
\begin{example}[Decomposing constraints-redundancy and contradiction]
    \begin{align*}
    &x \vdash x.\mathtt{fst} \equiv x.\mathtt{fst} &\mapsto& \top
    \tag{1}\\
    &x,y \vdash x.\mathtt{fst} \equiv y.\mathtt{fst} &\mapsto& \bot 
    \tag{2}\\
    &x \vdash x.\mathtt{fst} \equiv x.\mathtt{snd} &\mapsto& \bot 
    \tag{3}\\
    &\vdash \texttt{Cons(x, Nil)} \equiv \texttt{Cons(y, Nil)}&\mapsto& \bot
    \tag{4}\\
    \end{align*}
\end{example}
These example might be confusing at first. Looking at the third example, one might argue that there exists a pair, say $x = \mathtt{Tup(2,2)}$, such that
$x.\mathtt{fst} = x.\mathtt{snd}$. This is where it is important to remember that we are not looking for solutions to variables like $x$.
Whereas to our unification variables $\alphaunifvar$ we want to assign any term such that our equations hold, variables $x$ add \textit{constraints} to our equations. 
The equation $x \vdash x.\mathtt{fst} \equiv x.\mathtt{snd}$ must hold for \textit{any} variable $x$, since we cannot choose $x$! 
%TODO: rework sentence structure
%TODO: can i explain this better?

Since for $x = \mathtt{(2,3)}$, the equation does not hold, we can simplify to $\bot$.

\begin{example}[Decoposing constraints-splitting into smaller parts]
    \begin{align*}
    &\vdash \texttt{Cons(}\alphaunifvar, \texttt{Nil)}\equiv\texttt{Cons(}\alphaunifvar, \texttt{Nil)}
    &\mapsto&\alphaunifvar\equiv \betaunifvar
    \tag{5}\\
    &x \vdash x.\Ap{e_1}\equiv x.\Ap{e_2} &\mapsto& x\vdash e_1\equiv e_2 
    \tag{6}\\
    &\vdash \excopatmatch{\Ap{x}\Rightarrow \alphaunifvar} \equiv \excopatmatch{\Ap{x}\Rightarrow\betaunifvar} 
    &\mapsto&x\vdash \alphaunifvar \equiv \betaunifvar
    \tag{7}\\
    &x\vdash x.\expatmatch{\texttt{T} \Rightarrow e_2, \texttt{F} \Rightarrow e_2} \equiv x.\expatmatch{\texttt{T} \Rightarrow t_1, \texttt{F} \Rightarrow t_2}\footnotemark{}
    \\ &\mapsto x\vdash  e_1 \equiv t_1, x\vdash e_2\equiv t_2
    \tag{8}
    \end{align*}
\end{example}    
\footnotetext{\texttt{T} and \texttt{F} are stand-ins for $\True$ and $\False$.}

Note that none of these examples contain redexes, meaning the only way for the terms on each side of the equations to be equivalent,
is for them to be equivalent \textit{syntactically}. %TODO: zu ungenau?

We want to formulate rules which help us simplify equations like these.
\begin{definition}[Decomposing Constraints]
    \begin{align*}
    &\Psi \vdash x\equiv x&\mapsto&\top
    \tag{1}\\
    &\Psi \vdash \alphaunifvar \equiv \alphaunifvar&\mapsto& \top
    \tag{2}\\
    \circ\,&\Psi \vdash e_1.d({\overline{e}})\equiv e_2.d({\overline{t}})
    \\ &\mapsto \Psi\vdash e_1 \equiv e_2 \wedge \overline{\Psi\vdash e\equiv t}
    \tag{3}\\
    *\,&\Psi \vdash e_1.\expatmatch{\overline{K(\overline{x})\Rightarrow e}}\equiv e_2.\expatmatch{\overline{K(\overline{x})\Rightarrow t}}
    \\ &\mapsto \Psi, \overline{x} \vdash e_1 \equiv e_2\wedge \overline{\Psi, \overline{x}\vdash e\equiv t}
    \tag{4}\\
    \circ\,&\Psi\vdash K(\overline{e})\equiv K(\overline{t})&\mapsto&\overline{\Psi\vdash e\equiv t}
    \tag{5}\\
    *\, &\Psi\vdash \excopatmatch{\overline{d(\overline{x})\Rightarrow e}}\equiv 
    \excopatmatch{\overline{d(\overline{x})\Rightarrow t}}
    &\mapsto& \overline{\Psi, \overline{x}\vdash e \equiv t}
    \tag{6}\\
    &\Psi\vdash \excopatmatch{\overline{d(\overline{x})\Rightarrow e}}\equiv t 
    &\mapsto& \overline{\Psi,\overline{x} \vdash e \equiv t.d(\overline{x})}
    \tag{7}\\
    &\Psi\vdash t\equiv \excopatmatch{\overline{d(\overline{x})\Rightarrow e}} 
    &\mapsto& \overline{\Psi, \overline{x}\vdash t.d(\overline{x}) \equiv e}
    \tag{8}\\
    &\text{non-matching *- or $\circ$-equation}&\mapsto&\bot
    \tag{9}
    \end{align*}
\end{definition}
Rules 6-8 are taken from \cite{10.5555/2021953.2021960}, adapted to our syntax. 

For equations marked with *, we require the constructors (or destructors) to be equal to one another in each equation. 
We also require them to have the same list of variables as arguments, respectively (i.e. full syntactic equality).

For equations marked with $\circ$, we only require the constructors (or destructors) to be equal to one another in each equation. 
(i.e. no syntactic equality among arguments required).

(The reason for this discrepancy lies in the fact that are only expecting terms in normal form!)

If any of this does not hold in a given equation, rule 9 applies and we simplify to $\bot$.

Note that 7 (as well as 8 with being just the mirror of 7) are possible through eta-conversion:

\begin{align*}
    \excopatmatch{\overline{d(\overline{x})\Rightarrow e}}&\equiv t \tag*{$\equiv_{\eta}$}\\
    \excopatmatch{\overline{d(\overline{x})\Rightarrow e}}&\equiv \excopatmatch{\overline{d(\overline{x})\Rightarrow t.d(\overline{x})}} \tag*{6}\\
    &\mapsto \overline{e \equiv t.d(\overline{x})}
\end{align*}
(Annotations on the right are supposed to show what rule is being used to get to the statement below.)

\newpage 
(Nur weil ich eine Citation irgendwo brauche)
In \cite{DBLP:books/el/RV01/Dowek01}, Huet's algorithm is described. %TODO: spelling?



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Bibliography
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\addcontentsline{toc}{chapter}{Bibliography}

\bibliographystyle{abbrv}
\bibliography{mylit}
%% Obige Anweisung legt fest, dass BibTeX-Datei `mylit.bib' verwendet
%% wird. Hier koennen mehrere Dateinamen mit Kommata getrennt aufgelistet
%% werden.

\cleardoublepage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Erklaerung
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\thispagestyle{empty}
\section*{Selbständigkeitserklärung}

Hiermit versichere ich, dass ich die vorliegende Bachelorarbeit 
selbständig und nur mit den angegebenen Hilfsmitteln angefertigt habe und dass alle Stellen, die dem Wortlaut oder dem 
Sinne nach anderen Werken entnommen sind, durch Angaben von Quellen als 
Entlehnung kenntlich gemacht worden sind. 
Diese Bachelorarbeit wurde in gleicher oder ähnlicher Form in keinem anderen 
Studiengang als Prüfungsleistung vorgelegt. 

\vskip 3cm

Ort, Datum	\hfill Unterschrift \hfill 


%%% Ende
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{document}

\iffalse
Für wenn wir patterns in mehr kontext behandeln i guess

Some examples of patterns:
\begin{align*}
    \begin{split}
    t_1 &= \excopatmatch{\Ap{x}\Rightarrow \alphaunifvar.\Ap{x}} \\
    t_2 &= \excopatmatch{\Ap{x}\Rightarrow \excopatmatch{\Ap{y}\Rightarrow (\alphaunifvar.\Ap{y}).\Ap{x}}}    
    \end{split}
\end{align*} 
In each of these terms, our unification variable is applied to distinct variables which are bound through  cocases.

However, these terms are not patterns:
\begin{align*}
    \begin{split}
        t_3 &= (\alphaunifvar.\Ap{x}).\Ap{y}\\
        t_4 &= \excopatmatch{\Ap{y}\Rightarrow (\alphaunifvar.\Ap{x})}\\
        t_5 &= \excopatmatch{\Ap{x}\Rightarrow (\alphaunifvar.\Ap{x}).\Ap{x}}
    \end{split}
\end{align*}
as they all don't contain exactly one cocase per variable which would bind that variable distinctly.
%TODO: macht das sinn mit dem distinctly? 
\fi
